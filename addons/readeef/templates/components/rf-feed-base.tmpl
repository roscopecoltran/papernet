{% define "content" %}
<link rel="import" href="/dist/excess-router/excess-router.html">
<link rel="import" href="/dist/iron-collapse/iron-collapse.html">
<link rel="import" href="/dist/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="/dist/iron-icon/iron-icon.html">
<link rel="import" href="/dist/iron-icons/iron-icons.html">
<link rel="import" href="/dist/iron-icons/hardware-icons.html">
<link rel="import" href="/dist/iron-icons/social-icons.html">
<link rel="import" href="/dist/iron-pages/iron-pages.html">
<link rel="import" href="/dist/iron-scroll-threshold/iron-scroll-threshold.html">
<link rel="import" href="/dist/iron-signals/iron-signals.html">
<link rel="import" href="/dist/lazy-pages/lazy-pages.html">
<link rel="import" href="/dist/paper-fab/paper-fab.html">
<link rel="import" href="/dist/paper-icon-button/paper-icon-button.html">
<link rel="import" href="/dist/paper-input/paper-input.html">
<link rel="import" href="/dist/paper-item/paper-item.html">
<link rel="import" href="/dist/paper-menu-button/paper-menu-button.html">
<link rel="import" href="/dist/paper-menu/paper-menu.html">
<link rel="import" href="/dist/paper-ripple/paper-ripple.html">
<link rel="import" href="/dist/paper-spinner/paper-spinner.html">
<link rel="import" href="/dist/paper-toast/paper-toast.html">
<link rel="import" href="/dist/polymer/polymer.html">

<link rel="import" href="{% url "/component/rf-api" .base.r %}">
<link rel="import" href="{% url "/component/rf-app-scaffold" .base.r %}">
<link rel="import" href="{% url "/component/rf-feed" .base.r %}">
<link rel="import" href="{% url "/component/rf-keyboard-shortcuts" .base.r %}">

<dom-module id="rf-feed-base">
    <template>
		<style>
.drawer-menu a {
    color: var(--text-primary-color);
    text-decoration: none;
    min-height: 20px;
    font-size: 16px;

    @apply(--layout-horizontal);
    @apply(--layout-center);
}

.card {
    @apply(--card-style);
    @apply(--shadow-elevation-4dp);
    padding: 8px;
    margin-bottom: 16px;
}

.empty-list {
    font-family: "Roboto Slab";
    font-variant: small-caps;
    font-size: 2em;
    padding: 0.67em 2em;
}

.drawer-menu .submenu {
    margin-left: 16px;
}

.drawer-menu .submenu a {
    font-size: 14px;
}

.drawer-menu paper-icon-button.item {
    padding: 8px;
    margin-left: 4px;
}

.main-title paper-fab {
    position: fixed;
    right: 50px;
    top: 32px;
    z-index: 1;
    background: white;
}

.main-title .title-text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.update-available .main-title [icon="refresh"] {
    background: var(--paper-fab-notify-background);
	transition: var(--background-transition);
    color: var(--text-primary-color-inverse);
}

.main-title [route="feed"] {
    margin-top: -16px;
    margin-left: -8px;
    margin-bottom: -16px;
}
.main-title [route="article"] {
    margin-top: -8px;
    margin-left: -8px;
}

.feed-favicon {
    margin-right: 5px;
}

.main-title [icon="arrow-back"] {
    margin-right: 24px;
}
		</style>
		<style include="iron-flex"></style>
		<style include="iron-flex-alignment"></style>
		<excess-route route="/web/feed/:tagOrId/(.*)?" route-alias="feed" tag-or-id="{{ tagOrId }}"></excess-route>
		<excess-route route="/web/feed/:tagOrId/article/:articleId/:formatType?" route-alias="article" active="{{ articleActive }}" article-id="{{ articleId }}" format-type="{{ formatType }}"></excess-route>

        <rf-app-scaffold narrow="{{ narrow }}" class$="[[ _computeScaffoldClass(_updateAvailable) ]]">
            <div class="drawer-title">{% __ "Feeds" .base.lang %}</div>
            <div class="drawer-menu">
                <div hidden$="[[  _computeHideFeedItems(feeds) ]]">
                    <a href="[[ feedUrlFor('favorite') ]]" class="item">
                        <span>{% __ "Favorite" .base.lang %}</span>
                        <paper-ripple></paper-ripple>
                    </a>

                    <div class="layout horizontal center" hidden$="[[ !user.capabilities.Popularity ]]">
                        <paper-icon-button icon="expand-more" expands="popular-feeds" class="item" on-tap="onToggleExpand"></paper-icon-button>
                        <a href="[[ feedUrlFor('popular:all') ]]" class="layout horizontal flex">
                            <div style="position: relative" class="flex item">
                                {% __ "Popular" .base.lang %}
                                <paper-ripple></paper-ripple>
                            </div>
                        </a>
                    </div>
                    <iron-collapse id="popular-feeds" hidden$="[[ !user.capabilities.Popularity ]]">
                        <div class="menu submenu">
                            <template is="dom-repeat" items="[[ tags ]]">
                                <a href="[[ feedUrlFor(item.name, 'popular:tag') ]]" class="item">
                                    <span>[[ item.name ]]</span>
                                    <paper-ripple></paper-ripple>
                                </a>
                            </template>

                            <template is="dom-repeat" items="[[ feeds ]]">
                                <a href="[[ feedUrlFor(item.Id, 'popular') ]]" class="item">
                                    <img src="[[ _computeFavIconUrl(item) ]]" alt="favicon" class="feed-favicon">
                                    <span>[[ item.Title ]]</span>
                                    <paper-ripple></paper-ripple>
                                </a>
                            </template>
                        </div>
                    </iron-collapse>
                    <hr>

                    <template is="dom-repeat" items="[[ _computeNavigationTags(tags) ]]">
                        <div class="layout horizontal center">
                            <paper-icon-button icon="expand-more" expands$="[[ _computeNavigationExpandTag(item) ]]" class="item" on-tap="onToggleExpand"></paper-icon-button>
                            <a href="[[ repeaterTagUrl(item.name) ]]" class="layout horizontal flex">
                                <div style="position: relative" class="flex item">
                                    <span>[[ item.name ]]</span>
                                    <paper-ripple></paper-ripple>
                                </div>
                            </a>
                        </div>
                        <iron-collapse id="[[ _computeNavigationExpandTag(item) ]]">
                            <div class="menu submenu">
                                <template is="dom-repeat" items="[[ item.feeds ]]">
                                    <a href="[[ feedUrlFor(item.Id) ]]" class="item">
                                        <img src="[[ _computeFavIconUrl(item) ]]" alt="favicon" class="feed-favicon">
                                        <span>[[ item.Title ]]</span>
                                        <paper-ripple></paper-ripple>
                                    </a>
                                </template>
                            </div>
                        </iron-collapse>

                    </template>
                    <hr>
                </div>
                <a href="[[ urlFor('@settings-general') ]]" class="item">
                    <span>{% __ "Settings" .base.lang %}</span>
                    <paper-ripple></paper-ripple>
                </a>
                <a href="[[ urlFor('@logout') ]]" class="item">
                    <span>{% __ "Logout" .base.lang %}</span>
                    <paper-ripple></paper-ripple>
                </a>
            </div>
            <div class="main-title">
				<iron-pages attr-for-selected="route" selected="[[ display ]]">
					<section route="feed" class="layout horizontal center flex">
						<paper-icon-button icon="menu" paper-drawer-toggle></paper-icon-button>
						<paper-icon-button icon="arrow-back" style="visibility: hidden;" hidden$="[[ _computeHidePlaceholderIcon(searchVisible, narrow) ]]"></paper-icon-button>
						<span class="flex title-text" hidden$="[[ searchVisible ]]">[[ _computeFeedTitle(tagOrId, feeds) ]]</span>
						<span class="search-feed flex layout horizontal center" hidden$="[[ !searchVisible ]]">
							<paper-icon-button icon="clear" on-tap="toggleSearch"></paper-icon-button>
							<paper-input class="search-input" placeholder="{% __ "Search" .base.lang %}" no-label-float on-keyup="onSearchKeyUp" on-keypress="onSearchKeyPress" autofocus></paper-input>
						</span>

						<paper-icon-button icon="search" hidden$="[[ _computeHideSearchButton(user.*, tagOrId, searchVisible) ]]" title="{% __ "Search" .base.lang %}" on-tap="toggleSearch"></paper-icon-button>
						<paper-icon-button icon="refresh" title="{% __ "Refresh" .base.lang %}" on-tap="onRefresh" hidden$="[[ !narrow ]]"></paper-icon-button>
						<paper-menu-button horizontal-align="right">
							<paper-icon-button icon="more-vert" class="dropdown-trigger" title="{% __ "More options" .base.lang %}"></paper-icon-button>
							{%/* The second instance of the menu doesn't initialize its style correctly. Inline the background color */%}
							<paper-menu class="dropdown-content options-menu" multi attr-for-selected="name" on-iron-activate="onFeedMenuItemActivate" style="background: #fff" selected-values="[[ _computeOptionsMenuSelectedValues(user.*) ]]">
								<paper-item name="older-first">{% __ "Older first" .base.lang %}</paper-item>
								<paper-item name="unread-only">{% __ "Unread only" .base.lang %}</paper-item>
								<paper-item name="mark-all-as-read">{% __ "Mark all as read" .base.lang %}</paper-item>
							</paper-menu>
						</paper-menu-button>
					</section>
					<section route="article" class="layout horizontal center flex">
						<paper-icon-button icon="arrow-back" on-tap="onArticleUp"></paper-icon-button>
						<span class="title-text-article flex">[[ _computeFeedTitle(tagOrId, feeds) ]]</span>
						<paper-icon-button icon="[[ _computeReadStateIcon(_readState) ]]" title="{% __ "Mark article as read/unread" .base.lang %}" on-tap="onReadStateTap"></paper-icon-button>

						<paper-icon-button icon="hardware:keyboard-arrow-left" style$="[[ _computeHideArticleArrow(articleId, articles.splices, 'previous') ]]" title="{% __ "Previous article" .base.lang %}" on-tap="onPreviousArticle"></paper-icon-button>
						<paper-icon-button icon="hardware:keyboard-arrow-right" style$="[[ _computeHideArticleArrow(articleId, articles.splices, 'next') ]]" title="{% __ "Next article" .base.lang %}" on-tap="onNextArticle"></paper-icon-button>

						<paper-menu-button horizontal-align="right" hidden$="[[ !_shareServices.length ]]">
							<paper-icon-button icon="social:share" title="{% __ "Share article" .base.lang %}" class="dropdown-trigger"></paper-icon-button>
							{%/* The second instance of the menu doesn't initialize its style correctly. Inline the background color */%}
							<paper-menu class="dropdown-content options-menu" multi attr-for-selected="name" on-iron-activate="onShareServiceActivate" style="background: #fff">
								<template is="dom-repeat" items="[[ _shareServices ]]">
									<paper-item name="[[ item.name ]]">[[ item.description ]]</paper-item>
								</template>
							</paper-menu>
						</paper-menu-button>
					</section>
				</iron-pages>
                <paper-fab icon="refresh" on-tap="onRefresh" hidden$="[[ narrow ]]"></paper-fab>
            </div>
            <div class="main-content">
                <iron-scroll-threshold id="scroll-threshold" lower-threshold="100" on-lower-trigger="onLowerScrollThresholdTrigger"></iron-scroll-threshold>

                <rf-feed id="feed" user="[[ user ]]" feeds="[[ feeds ]]" articles="[[ articles ]]" narrow="[[ narrow ]]" tag-or-id="[[ tagOrId ]]" article-id="[[ articleId ]]" format-type="[[ formatType ]]" display="[[ display ]]" on-feed-article-state="onFeedArticleState"></rf-feed>

                <div class="card empty-list" hidden$="[[ _computeHideEmptyMessage(articles.*, loading) ]]">
                    <span>{% __ "There are no articles in this section" .base.lang %}</span>
                </div>

                <div class="layout vertical center" hidden$="[[ !loading ]]">
                    <paper-spinner id="loading-spinner" active="[[ loading ]]"></paper-spinner>
                </div>

            </div>
        </rf-app-scaffold>

        <paper-toast id="no-new-articles" text="{% __ "Articles are up-to-date" .base.lang %}"></paper-toast>

        <rf-api id="list-feeds" method="list-feeds" on-rf-api-message="onAllFeedsMessage"></rf-api>
        <rf-api id="user-settings" method="set-user-attribute" tag="feed-base"></rf-api>
        <rf-api id="feed-articles" method="get-feed-articles" on-rf-api-message="onFeedArticlesMessage" on-rf-api-error="onFeedArticlesError" on-rf-api-reconnect="onFeedArticlesReconnect"></rf-api>
        <rf-api id="get-article" method="get-article" on-rf-api-message="onGetArticleMessage"></rf-api>
        <rf-api id="feed-read-all" method="read-state" on-rf-api-message="onFeedReadAllMessage"></rf-api>
        <rf-api id="feed-update-notifier" method="feed-update-notifier" on-rf-api-message="onFeedUpdateNotify" receiver="true"></rf-api>

        <iron-signals on-iron-signal-rf-feeds-added="onSignalFeedsChanged"></iron-signals>
        <iron-signals on-iron-signal-rf-feed-removed="onSignalFeedsChanged"></iron-signals>
        <iron-signals on-iron-signal-rf-feed-tags-changed="onSignalFeedTagsChanged"></iron-signals>

        <rf-keyboard-shortcut route-name="article" key-code="72, 104" label="h" description="Go back to the article list" on-press="onArticleUp"></rf-keyboard-shortcut>

        <rf-keyboard-shortcut route-name="feed" key-code="106" label="j" description="Go to the next loaded article" on-press="onNextArticle"></rf-keyboard-shortcut>
        <rf-keyboard-shortcut route-name="feed" key-code="74" label="Shift + j" description="Go to the next unread loaded article" on-press="onNextUnreadArticle"></rf-keyboard-shortcut>

        <rf-keyboard-shortcut route-name="feed" key-code="107" label="k" description="Go to the previous loaded article" on-press="onPreviousArticle"></rf-keyboard-shortcut>
        <rf-keyboard-shortcut route-name="feed" key-code="75" label="Shift + k" description="Go to the previous loaded unread article" on-press="onPreviousUnreadArticle"></rf-keyboard-shortcut>

        <rf-keyboard-shortcut route-name="feed, !article" key-code="47" label="/" description="Search" on-press="onToggleSearch"></rf-keyboard-shortcut>

        <rf-keyboard-shortcut route-name="feed" key-code="82, 114" label="r" description="Fetch the latest articles and refresh the list" on-press="refresh"></rf-keyboard-shortcut>
    </template>

    <script>
        "use strict";
        Polymer({
            is: "rf-feed-base",
            behaviors: [
                UserBehavior,
				RouteBehavior,
				ThemeBehavior,
            ],
            properties: {
				user: {
					type: Object,
					observer: '_userChanged',
				},
                tagOrId: {
                    type: String,
                    observer: '_tagOrIdChanged',
                },
				articleId: {
					type: Number,
					observer: '_articleIdChanged',
				},
				formatType: String,
                feeds: {
                    type: Array,
                    notify: true,
                    observer: '_feedsChanged',
                    value: function() {
                        return [];
                    },
                },
                articles: {
                    type: Array,
                    value: function() {
                        return this._createArticles();
                    },
                },
                loading: {
                    type: Boolean,
                },
                tags: Array,
                searchVisible: {
                    type: Boolean,
                    value: false,
                },
                limit: {
                    type: Number,
                    value: 200,
                },
				articleActive: {
					type: Boolean,
					observer: '_articleActiveChanged',
				},
				display: String,
                _readState: Boolean,
                _shareServices: Array,
                _updateAvailable: {
                    type: Boolean,
                    value: false,
                },
            },
            observers: [
                '_userProfileChanged(user.ProfileData.*)',
            ],

            _focused: true,
            _urlParser: document.createElement('a'),

            feedUrlFor: function(tagOrId, prefix) {
                if (prefix) {
                    tagOrId = prefix + ":" + tagOrId;
                }
				return Excess.RouteManager.getRoutePath('@feed', {tagOrId: tagOrId});
            },

            repeaterTagUrl: function(name) {
                if (name == "{% __ "All" .base.lang %}") {
                    return this.feedUrlFor('all');
                } else {
                    return this.feedUrlFor(name, 'tag');
                }
            },

            toggleSearch: function() {
                this.searchVisible = !this.searchVisible;
                if (this.searchVisible) {
                    // Get the currently active search input
                    var search = Polymer.dom(
                        Polymer.dom(this.root).querySelector('rf-app-scaffold').root
                    ).querySelector('.search-input');
                    if (search) {
                        search.$.input.focus();
                    }
                } else if (this.tagOrId.indexOf("search:") == 0) {
                    var tagOrId = this._extractSearchTokens(this.tagOrId)[0];
					Excess.RouteManager.transitionTo('@feed', {tagOrId: tagOrId});
                }
            },

            refresh: function(type) {
                this.debounce('feed-refresh', function() {
                    this.loading = true;
                    this.noMoreArticles = false;

                    switch (type) {
                        case 'get-article':
                            this.$['get-article'].send();
                            break;
                        default:
							this._getFeedArticles({minId: this._minArticleId, maxId: this._maxArticleId});
                    }
                });
            },

            attached: function() {
                this._appendArticleWorker = new Worker('/js/append-articles-worker.js');
                this._appendArticleWorker.addEventListener('message',
						this._handleArticleWorkerMessage.bind(this));

                this._shareServices = RfShareServices.getActive();

                this.$['scroll-threshold'].scrollTarget =
                    Polymer.dom(this.root).querySelector('rf-app-scaffold').mainScroller;

                window.addEventListener("focus", function() {
                    this._focused = true;
                    document.title = this._originalTitle;
                }.bind(this), false);
                window.addEventListener("blur",
						function() {this._focused = false}.bind(this), false);

                this._originalTitle = document.title;

				this._refreshInterval = setInterval(function() {
					this._getFeedArticles();
				}.bind(this), 1800000);

				this.async(function() {
					this.$['list-feeds'].send();
				});
            },

			detached: function() {
				clearInterval(this._refreshInterval);
			},

            onFeedArticleState: function(event, detail) {
                if ('Read' in detail) {
                    if (this._ignoreReadDebouncer) {
                        this._readState = detail.Read;
                        this._ignoreReadDebouncer = false;
                    } else {
                        this.debounce('article-read-state', function() {
                            this._readState = detail.Read;
                        }, 1000);
                    }
                }
            },

            onAllFeedsMessage: function(event, detail) {
                this.feeds = detail.arguments.Feeds;
            },

            onFeedArticlesMessage: function(event, data) {
                this._updateAvailable = false;

                var data = {
                    current: [].concat(this.articles),
                    newArticles: data.arguments.Articles,
                    olderFirst: this.user.ProfileData.olderFirst,
                    unreadOnly: this.user.ProfileData.unreadOnly,
                    treatAsUnread: this._treatAsUnread,
                    unreadIds: data.arguments.UnreadIds,
                    favoriteIds: data.arguments.FavoriteIds,
                    updateRequest: !!data.arguments.MaxId,
                    lang: "{% .base.lang %}",
                };

                delete this._treatAsUnread;

                if (isNaN(this.tagOrId)) {
                    data.feeds = this.feeds;
                }

                this._appendArticleWorker.postMessage(data);
            },

            onFeedArticlesError: function(event, detail) {
                this.loading = false;
            },

			onFeedArticlesReconnect: function(event) {
				this.debounce('feed-refresh', function() {
					this.refresh();
				});
			},

            onGetArticleMessage: function(event, data) {
                var article = event.detail.arguments.Article;

                if (article) {
                    var data = {
                        current: [].concat(this.articles),
                        newArticles: [article],
                        olderFirst: this.user.ProfileData.olderFirst,
                        unreadOnly: this.user.ProfileData.unreadOnly,
                        requestedArticle: article.Id,
                    };

                    if (isNaN(this.tagOrId)) {
                        data.feeds = this.feeds;
                    }

                    this._appendArticleWorker.postMessage(data);
                }
            },

            onFeedReadAllMessage: function(event, data) {
                if (data.success) {
                    for (var i = 0, a; a = this.articles[i]; ++i) {
                        this.set("articles." + i + ".Read", true);
                    }
                }
            },

            onFeedUpdateNotify: function(event, data) {
                var updateAvailable = false;
               
                if (this.tagOrId.indexOf("tag:") == 0) {
                    var tag = this.tagOrId.substring(4),
                        active = this.feeds.filter(function(feed) {
                            return feed.Tags && feed.Tags.indexOf(tag) != -1 
                        });

                    if (active.some(function(feed) { return feed.Id == data.arguments.Feed.Id })) {
                        updateAvailable = true;
                    }

                } else if (this.tagOrId == "all" || this.tagOrId == data.arguments.Feed.Id) {
                    updateAvailable = true;
                }

                if (!updateAvailable) {
                    return;
                }

                this._updateAvailable = true;

                this.debounce('auto-update-timeout', this._updateArticles);

                if (!this._focused) {
                    // Highlight a pinned tab
                    document.title = this._originalTitle + " (New content available)";
                }

				// Electron integration
				var event = new CustomEvent("updates-available", {
					detail: {
						title: data.arguments.Feed.Title,
						id: data.arguments.Feed.Id,
					},
				});
				window.dispatchEvent(event);
            },

            onSignalFeedsChanged: function() {
                this.$['list-feeds'].send();
            },

            onSignalFeedTagsChanged: function(event, detail) {
                for (var i = 0, f; f = this.feeds[i]; ++i) {
                    if (f.Id == detail.Id) {
                        f.Tags = detail.Tags;

                        this._updateTags();
                        this.set('feeds.' + i, f);
                    }
                }
            },

            onToggleExpand: function(event) {
                var element = Polymer.dom(event).localTarget;

                var collapser = Polymer.dom(this.root).querySelector(
                        '#' + element.getAttribute('expands'));

                if ('icon' in element) {
                    element.icon = collapser.opened ? 'expand-more' : 'expand-less';
                }
                collapser.toggle();
            },

            onArticleUp: function() {
				Excess.RouteManager.transitionTo('@feed', {tagOrId: this.tagOrId});
            },

            onToggleSearch: function() {
                if (!this._searchAvailable(this.tagOrId) || this.searchVisible) {
                    return;
                }

                this.toggleSearch();
            },

            onReadStateTap: function(event) {
                var element = Polymer.dom(event).localTarget;

                this._ignoreReadDebouncer = true;
                this.flushDebouncer('article-read-state');
                this.$.feed.articleState(this.articleId,
                    {Read: !this.articles.find(this.articleId).Read});
            },

            onPreviousArticle: function() {
                this._previousArticle();
            },

            onPreviousUnreadArticle: function() {
                this._previousArticle(true);
            },

            onNextArticle: function() {
                this._nextArticle();
            },

            onNextUnreadArticle: function() {
                this._nextArticle(true);
            },

            onRefresh: function() {
				Excess.RouteManager.transitionTo('@feed', {tagOrId: this.tagOrId});
                this.refresh();
            },

            onFeedMenuItemActivate: function(event) {
                // Event is fired before the actual selection takes place
                var menu = Polymer.dom(event).localTarget,
                    name = event.detail.selected;

                switch (name) {
                case "older-first":
                    this.set("user.ProfileData.olderFirst", !this.user.ProfileData.olderFirst);
                    this.articles = this._createArticles();
                    this.refresh();
                    break;
                case "unread-only":
                    this.set("user.ProfileData.unreadOnly", !this.user.ProfileData.unreadOnly);
                    this.articles = this._createArticles();
                    this.refresh();
                    break;
                case "mark-all-as-read":
                    this._markAllAsRead();
                    break;
                }

                event.preventDefault();
                Polymer.dom(menu).parentNode.close();
            },

            onShareServiceActivate: function(event) {
                var menu = Polymer.dom(event).localTarget,
                    name = event.detail.selected,
                    selected = (menu.selectedValues || []).indexOf(name) == -1;

                if (selected) {
                    menu.select(name);
                    window.open(RfShareServices.get(name).url, '_blank');
                }
            },

            onSearchKeyUp: function(event) {
                var code = event.keyCode || event.charCode,
                    target = Polymer.dom(event).localTarget;

                switch (code) {
                    case 13: // Enter
                        if (target.value !== "") {
							Excess.RouteManager.transitionTo('@feed', {
                                tagOrId: "search:" + this._extractSearchTokens(this.tagOrId)[0] + ":" + target.value,
                            });
                        }
                        break;
                    case 27: // Esc
                        this.toggleSearch();
                        break;
                }

                event.stopPropagation();
            },

            onSearchKeyPress: function(event) {
                event.stopPropagation();
            },

            onLowerScrollThresholdTrigger: function(event) {
                if (this.noMoreArticles || this.articleActive || this.loading) {
                    this.$['scroll-threshold'].clearLower();
                    return;
                }
				this._fetchNextArticles();
            },

			_userChanged: function(user, old) {
				this.refresh();
			},

            _tagOrIdChanged: function(tagOrId, old) {
                this.articles = this._createArticles();
                this.refresh();

				if (tagOrId.indexOf("search:") == 0) {
					this.searchVisible = true;
					var term = this._extractSearchTokens(tagOrId)[1];

					Polymer.dom(this.root).querySelectorAll('.search-input').forEach(function(input) {
						input.value = term;
					});
				} else {
					this.searchVisible = false;
				}
            },

			_articleIdChanged: function(id, old) {
				if (!this.articles.length) {
					this.cancelDebouncer('feed-refresh');

					this.$['get-article'].args = {id: id - 0};
					this.refresh('get-article');
				} else {
					this._processArticle(id);
				}
			},

            _feedsChanged: function(newValue, old) {
                this._updateTags();
            },

			_articleActiveChanged: function(active, old) {
				this.debounce('article-route-change', function() {
					this.display = active ? 'article' : 'feed';
				}.bind(this));
			},

            _userProfileChanged: function(userProfileRecord) {
                if (this.user) {
                    this.$['user-settings'].send({
                        attribute: "ProfileData",
                        value: this.user.ProfileData
                    });
                }
            },

            _computeScaffoldClass: function(updateAvailable) {
                return updateAvailable ? 'update-available' : '';
            },

            _computeHidePlaceholderIcon: function(searchVisible, narrow) {
                return searchVisible || narrow;
            },

            _computeFeedTitle: function(tagOrId) {
                if (tagOrId == "all") {
                    return '{% __ "All feed articles" .base.lang %}';
                } else if (tagOrId == "favorite") {
                    return '{% __ "Favorite feed articles" .base.lang %}';
                } else if (tagOrId.indexOf("popular:") == 0) {
                    var sub = tagOrId.substring("popular:".length);

                    if (sub == "all") {
                        return '{% __ "Popular feed articles" .base.lang %}';
                    } else if (sub.indexOf("tag:") == 0) {
                        return '{% __ "Popular articles from { Tag }" .base.lang %}'.replace(/{\s*Tag\s*}/, tagOrId.substring("tag:".length));
                    } else if (!isNaN(sub)) {
                        var feed = this.feeds.filter(function(f) { return f.Id == sub })[0];
                        if (feed) {
                            return '{% __ "Popular articles from { Tag }" .base.lang %}'.replace(/{\s*Tag\s*}/, feed.Title);
                        }
                    }
                } else if (tagOrId.indexOf("search:") == 0) {
                    var parts = this._extractSearchTokens(tagOrId),
                        sub = parts[0],
                        term = parts[1];

                    if (sub == "all") {
                        return '{% __ "Search results for { Term }" .base.lang %}'.replace(/{\s*Term\s*}/, term);
                    } else if (sub.indexOf("tag:") == 0) {
                        return '{% __ "Search results for { Term } from { Tag }" .base.lang %}'.replace(/{\s*Term\s*}/, term).replace(/{\s*Tag\s*}/, tagOrId.substring("tag:".length));
                    } else if (!isNaN(sub)) {
                        var feed = this.feeds.filter(function(f) { return f.Id == sub })[0];
                        if (feed) {
                            return '{% __ "Search results for { Term } from { Tag }" .base.lang %}'.replace(/{\s*Term\s*}/, term).replace(/{\s*Tag\s*}/, feed.Title);
                        }
                    }
                } else if (tagOrId.indexOf("tag:") == 0) {
                    var sub = tagOrId.substring("tag:".length);

                    return '{% __ "Articles from { Tag }" .base.lang %}'.replace(/{\s*Tag\s*}/, tagOrId.substring("tag:".length));
                } else if (!isNaN(tagOrId)) {
                    var feed = this.feeds.filter(function(f) { return f.Id == tagOrId })[0];
                    if (feed) {
                        return feed.Title;
                    }
                }
            },

            _computeHideFeedItems: function(feeds) {
                return this.feeds.length == 0;
            },

            _computeFavIconUrl: function(feed) {
                this._urlParser.href = feed.Link

                return "//www.google.com/s2/favicons?domain=" + this._urlParser.host;
            },

            _computeNavigationTags: function(tags) {
                return [].concat({name: '{% __ "All" .base.lang %}', feeds: this.feeds}, this.tags);
            },

            _computeNavigationExpandTag: function(item) {
                return 'feeds-' + item.name;
            },

            _computeHideSearchButton: function(userRecord, tagOrId, searchVisible) {
                return !this._searchAvailable(tagOrId) || searchVisible;
            },

            _computeOptionsMenuSelectedValues: function(userRecord) {
                if (!this.user) {
                    return;
                }

                var selected = [];

                if (this.user.ProfileData.olderFirst) {
                    selected.push("older-first");
                }

                if (this.user.ProfileData.unreadOnly) {
                    selected.push("unread-only");
                }

                return selected;
            },

            _computeReadStateIcon: function(readState) {
                return readState ? 'check-box' : 'check-box-outline-blank';
            },

            _computeHideArticleArrow(articleId, splices, direction) {
                if (direction == 'previous') {
                    return this.articles.findIndex(articleId) > 0 ? "" : "visibility: hidden";
                } else {
                    return this.articles.findIndex(articleId) < this.articles.length ?
                        "" : "visibility: hidden";
                }
            },

            _computeHideEmptyMessage: function(articleRecord, loading) {
                return loading || articleRecord.base.length > 0;
            },


            _getFeedArticles: function(args) {
                if (!this.user) {
                    return;
                }


                var defaults = {
                    id: this.tagOrId,
                    limit: this.limit,
                    offset: 0,
                    olderFirst: this.user.ProfileData.olderFirst || false,
                    unreadOnly: this.user.ProfileData.unreadOnly || false,
                };

				this.$['feed-articles'].send(Polymer.Base.mixin(defaults, args || {}));
            },

            _extractSearchTokens: function(tagOrId) {
                var parts = tagOrId.split(":"), term, sub;

                if (parts[0] != "search") {
                    return [parts.join(':'), null];
                }

                parts.shift();
                sub = parts[0];

                if (sub == "tag") {
                    sub = parts.splice(0, 2).join(":")
                } else {
                    sub = parts.shift();
                }

                term = decodeURIComponent(parts.join(":"));

                return [sub, term];
            },

            _searchAvailable: function(tagOrId) {
                return this.user && this.user.capabilities.Search &&
                    tagOrId != 'favorite' &&
                    tagOrId.indexOf('popular:') != 0 &&
                    tagOrId.indexOf('search:') != 0;
            },

            _updateTags: function() {
                var tagList = [], tags = {};

                this.feeds.forEach(function(feed) {
                    if (feed.Tags && feed.Tags.length) {
                        for (var i = 0, tag; tag = feed.Tags[i]; ++i) {
                            if (!tags[tag]) {
                                tags[tag] = [];
                            }

                            tags[tag].push(feed);
                        }
                    }
                });

                Object.keys(tags).sort().forEach(function(tag) {
                    tagList.push({name: tag, feeds: tags[tag]});
                });

                this.tags = tagList;
            },

            _updateArticles: function() {
                if (!this._updateAvailable) {
                    return;
                }

				this._getFeedArticles({minId: this._minArticleId, maxId: this._maxArticleId});
            },

            _previousArticle: function(unread) {
                var article;
                if (this.articleActive) {
                    var index = this.articles.findIndex(this.articleId);

                    if (unread) {
                        while (article = this.articles[--index]) {
                            if (!article.Read) {
                                break;
                            }
                        }
                    } else if (index > 0) {
                        article = this.articles[index - 1];
                    }
                } else {
                    if (unread) {
                        var article, index = this.articles.length;
                        while (article = this.articles[--index]) {
                            if (!article.Read) {
                                break;
                            }
                        }
                    } else {
                        article = this.articles[this.articles.length - 1];
                    }
                }

                if (article) {
					Excess.RouteManager.transitionTo('@article', {tagOrId: this.tagOrId, articleId: article.Id});
                }
            },

            _nextArticle: function(unread) {
                var article;
                if (this.articleActive) {
                    var index = this.articles.findIndex(this.articleId);

                    if (unread) {
                        while (article = this.articles[++index]) {
                            if (!article.Read) {
                                break
                            }
                        }
                    } else {
                        article = this.articles[index+1]
                    }
                } else {
                    var index = -1;
                    if (unread) {
                        while (article = this.articles[++index]) {
                            if (!article.Read) {
                                break
                            }
                        }
                    } else {
                        article = this.articles[0];
                    }
                }

                if (article) {
					Excess.RouteManager.transitionTo('@article', {tagOrId: this.tagOrId, articleId: article.Id});
                }
            },

            _markAllAsRead: function() {
                if (this._maxArticleId) {
                    this.$['feed-read-all'].send({id: this.tagOrId, beforeId: this._maxArticleId + 1});
                }
            },

            _createArticles: function() {
                var articles = [];

                articles.indexMap = {};
                articles.find = function(id) {
                    return this[this.indexMap[id]];
                };
                articles.findIndex = function(id) {
                    var index = this.indexMap[id];
                    return index === undefined ? -1 : index;
                };

                this._minArticleId = 0;
                this._maxArticleId = 0;
                return articles;
            },

			_fetchNextArticles: function(indexAsUnread) {
				if (arguments.length > 0 && indexAsUnread != -1) {
					// Force the article to be treated as unread,
					// so that newly received articles that are
					// older than it can be placed at the end
					this._treatAsUnread = indexAsUnread;
				}

				this.debounce('feed-refresh', function() {
					this.loading = true;
					this._getFeedArticles({offset: this.articles.length});
				});
			},

			_processArticle: function(id) {
				var index = this.articles.findIndex(id),
					article = this.articles[index];

				if (!article) {
					return;
				}

				this.cancelDebouncer('article-read-state');
				this._readState = article.Read;
				this._ignoreReadDebouncer = false;
				this._shareServices.forEach(function(service) {
					service.article = article;
				}.bind(this));

				if (index == 0) {
					this.debounce('auto-update-timeout', this._updateArticles);
				} else if (index == this.articles.length - 1) {
					this._fetchNextArticles(index);
				}
			},

            _handleArticleWorkerMessage: function(event) {
                this.$.feed.preArticlesUpdate(event.data.inserts, event.data.stateChange);

                // Update the map first, the change callbacks might use it
                this.articles.indexMap = event.data.indexMap;

                var updated = false;
                for (var i = 0, insert; insert = event.data.inserts[i]; ++i) {
                    this.splice.apply(this, ['articles', insert.index, 0].concat(insert.articles));
                    updated = true;
                }

                for (var id in event.data.stateChange) {
                    var state = event.data.stateChange[id],
                        index = this.articles.findIndex(id);

                    if ('Read' in state) {
                        this.set('articles.' + index + '.Read', state.Read);
                    }

                    if ('Favorite' in state) {
                        this.set('articles.' + index + '.Favorite', state.Favorite);
                    }

                    updated = true;
                }

                this.$['scroll-threshold'].clearLower();

                if (event.data.requestedArticle !== undefined) {
					this._getFeedArticles();
                    if (event.data.requestedArticle) {
						if (this.articleActive) {
							this._processArticle(this.articleId);
						} else {
							Excess.RouteManager.transitionTo('@article',
									{tagOrId: this.tagOrId, articleId: event.data.requestedArticle});
						}
                    } else {
						Excess.RouteManager.transitionTo('@feed', {tagOrId: this.tagOrId});
                    }
                } else {
                    this._minArticleId = event.data.minId;
                    this._maxArticleId = event.data.maxId;
                    this.loading = false;

					if (this.articleActive) {
						var index = this.articles.findIndex(this.articleId);
						if (index == this.articles.length - 1) {
							this._fetchNextArticles(index);
						}
					}
                }

                if (!updated) {
                    if (event.data.updateRequest) {
                        this.$['no-new-articles'].show();
                    } else {
                        this.noMoreArticles = true;
                    }
                }
            },

        })
    </script>
</dom-module>
{% end %}
